# -*- coding: utf-8 -*-
"""Matriz de Confusão.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y3ba4ssFVX2nt62twEXYLro7C6sc87pr

Matrix de Confusão
---
Este código implementa uma rede neural convolucional (CNN) para classificação de dígitos manuscritos utilizando o dataset MNIST. A rede neural é treinada para identificar os dígitos de 0 a 9 em imagens de 28x28 pixels.
"""

pip install tensorflow

# Importação das bibliotecas necessárias
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
from tensorflow.keras import datasets, layers, models

# Carregando o dataset MNIST (dígitos escritos à mão)
(train_images, train_labels), (test_images, test_labels) = datasets.mnist.load_data()

# Remodelando os dados para adicionar um canal de cor
train_images = train_images.reshape((60000, 28, 28, 1))
test_images = test_images.reshape((10000, 28, 28, 1))

train_images, test_images = train_images / 255.0, test_images / 255.0

classes=[0,1,2,3,4,5,6,7,8,9]

# Definição da rede neural convolucional
model = models.Sequential([
    layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.MaxPooling2D((2, 2)),
    layers.Conv2D(64, (3, 3), activation='relu'),
    layers.Flatten(),
    layers.Dense(64, activation='relu'),
    layers.Dense(10, activation='softmax')
])

tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir, histogram_freq=1)

# Compilação do modelo
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Treinamento do modelo
model.fit(train_images, train_labels, epochs=5, validation_data=(test_images, test_labels))

# Fazendo previsões no conjunto de teste
y_pred = model.predict(test_images)

# Convertendo as probabilidades para classes previstas
y_pred_classes = np.argmax(y_pred, axis=1)

# Gerando a matriz de confusão
conf_matrix = confusion_matrix(test_labels, y_pred_classes)

# Normalizando a matriz de confusão para exibir as proporções
conf_matrix_norm = np.around(conf_matrix.astype('float') / conf_matrix.sum(axis=1)[:, np.newaxis], decimals=2)

# Criando um DataFrame para a visualização
classes = list(range(10))
conf_matrix_df = pd.DataFrame(conf_matrix_norm, index=classes, columns=classes)

# Plotando a matriz de confusão
plt.figure(figsize=(8, 8))
sns.heatmap(conf_matrix_df, annot=True, cmap=plt.cm.Blues, fmt=".2f")
plt.ylabel('Rótulo Verdadeiro')
plt.xlabel('Rótulo Previsto')
plt.title('Matriz de Confusão Normalizada')
plt.show()

# Cálculo dos valores separados da matriz de confusão
conf_matrix = confusion_matrix(test_labels, y_pred_classes)

# Inicializando os valores de TP, FP, FN, TN
TP = np.diag(conf_matrix)  # Verdadeiros Positivos: Diagonal da matriz
FP = np.sum(conf_matrix, axis=0) - TP  # Falsos Positivos: Soma das colunas, excluindo a diagonal
FN = np.sum(conf_matrix, axis=1) - TP  # Falsos Negativos: Soma das linhas, excluindo a diagonal
TN = np.sum(conf_matrix) - (FP + FN + TP)  # Verdadeiros Negativos: Resto dos elementos

# Exibindo os valores
print("Matriz de Confusão:")
print(conf_matrix)
print(f"Verdadeiros Positivos (TP): {TP}")
print(f"Falsos Positivos (FP): {FP}")
print(f"Falsos Negativos (FN): {FN}")
print(f"Verdadeiros Negativos (TN): {TN}")

# Cálculo da Sensibilidade (Recall)
sensibilidade = TP / (TP + FN)
print(f"Sensibilidade (Recall) por classe: {sensibilidade}")

# Cálculo da Acurácia
acuracia = (TP + TN) / (TP + TN + FP + FN)
print(f"Acurácia por classe: {acuracia}")

# Cálculo da Precisão
precisao = TP / (TP + FP)
print(f"Precisão por classe: {precisao}")

# Cálculo do F1-score
f1_score = 2 * (precisao * sensibilidade) / (precisao + sensibilidade)
print(f"F1-score por classe: {f1_score}")

# Calculando a média das métricas
acuracia_media = np.mean(acuracia)
precisao_media = np.mean(precisao)
sensibilidade_media = np.mean(sensibilidade)
f1_media = np.mean(f1_score)

# Exibindo as médias
print(f"\nAcurácia média: {acuracia_media:.4f}")
print(f"Precisão média: {precisao_media:.4f}")
print(f"Sensibilidade média: {sensibilidade_media:.4f}")
print(f"F1-score médio: {f1_media:.4f}")

# Imagem de teste
image_index = 0
image = test_images[image_index]
label = test_labels[image_index]

# Previsão para essa imagem
image = image.reshape((1, 28, 28, 1))
predicted_label = np.argmax(model.predict(image))

# Plotando a imagem
plt.imshow(test_images[image_index].reshape(28, 28), cmap=plt.cm.binary)
plt.title(f"Rótulo Verdadeiro: {label}, Rótulo Previsto: {predicted_label}")
plt.show()

# Exibindo os resultados
print("Matriz de Confusão:")
print(conf_matrix)
print(f"\nAcurácia: {accuracy:.4f}")
print(f"Precisão: {precision:.4f}")
print(f"Recall: {recall:.4f}")
print(f"F1-score: {f1:.4f}")